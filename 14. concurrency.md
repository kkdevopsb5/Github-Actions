## Concurrency Problem Statement

Without concurrency control, GitHub Actions will run multiple workflow runs at the same time, even if they belong to the same branch or same purpose.

This causes problems such as:

1. Multiple deployments running at the same time
2. Confusion about which run is the latest
3. Workflow runs overwriting each other
4. Race conditions (two pipelines updating same file or same environment)
5. Wasting runner minutes
6. Unnecessary load on backend servers
7. Conflicts when writing to same artifact or same folder

Example scenario:

If you push code 5 times quickly to the main branch, GitHub Actions will start 5 workflow runs parallelly.

This may break your deployment or overwrite environment.

To avoid this, we use **concurrency**.

---

## What is Concurrency in GitHub Actions

Concurrency is a feature that controls **how many workflow runs are allowed at the same time** for a particular workflow or group.

It can:

1. Cancel old running workflows
   or
2. Queue new workflows until the previous one completes

Concurrency is defined with a group name.

---

## How concurrency works

Two parts:

group:
Defines which workflows belong to the same group.

cancel-in-progress:
If set to true, ongoing runs are automatically cancelled when a new run starts.

---

## Basic Concurrency Example

```
name: Concurrency Demo

on:
  push:
    branches: [ main ]

concurrency:
  group: main-branch-group
  cancel-in-progress: true

jobs:
  demo:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Running workflow"
      - run: sleep 30
      - run: echo "Finished"
```

Explanation:

If you push 3 times quickly:

Old run is cancelled
New run starts
Only one run will execute at a time

cancel-in-progress: true ensures only the latest run proceeds.

---

## Why concurrency is required

1. Prevent duplicate deployments
2. Avoid environment corruption
3. Ensure only latest commit is deployed
4. Reduce runner usage
5. Maintain CI/CD stability
6. Avoid two pipelines working on the same files

Example real problem:

If deployment takes 2 minutes and you push code again during deployment, your first deployment is unnecessary.
Concurrency cancels the first run and runs only the newest one.

---

## Branch Based Concurrency Example

```
concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true
```

Explanation:
Each branch will have its own concurrency group.
Runs from same branch will not overlap.

---

## Environment Based Concurrency Example

```
concurrency:
  group: production
  cancel-in-progress: false
```

Explanation:
Only one workflow can deploy to production at a time.
New runs wait until old run completes.
No cancellation happens.

---

## Queue Mode Example (do not cancel running jobs)

```
concurrency:
  group: nightly-builds
  cancel-in-progress: false
```

Explanation:
If a new run starts, it waits in queue.
Old run continues uninterrupted.

---

## Using PR Number for Concurrency

```
concurrency:
  group: pr-${{ github.event.pull_request.number }}
  cancel-in-progress: true
```

Explanation:
Each pull request has its own concurrency group.
If same PR triggers multiple runs, only latest run continues.

---

## Complete Deployment Example Using Concurrency

```
name: Deployment Workflow

on:
  push:
    branches: [ main ]

concurrency:
  group: deploy-main
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Deploying latest version"
      - run: sleep 20
      - run: echo "Deployment complete"
```

Explanation:
If you push multiple times, only latest deployment runs.
Older deployments are cancelled.

---

## Simple Final Explanation

Concurrency ensures that only one workflow run executes for a specific group.
It removes duplicates, prevents conflicts, and ensures stability in CI/CD.

---
